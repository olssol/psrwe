#' Get posterior samples based on PS-power prior approach (WATT)
#'
#' Draw posterior samples of the parameters of interest for the PS-power prior
#' approach with weights of ATT (WATT)
#'
#'
#' @param dta_psbor A class \code{PSRWE_BOR} object generated by
#'     \code{\link{psrwe_borrow}}.
#' @param v_outcome Column name corresponding to the outcome.
#' @param outcome_type Type of outcomes: \code{continuous} or \code{binary}.
#' @param prior_type Whether treat power parameter as fixed (\code{fixed}) or
#'     fully Bayesian (\code{random}).
#' @param mcmc_binary MCMC sampling via either \code{rstan} or \code{analytic}
#'     (only for \code{outcome_type = "binary"} and
#'     \code{prior_type = "fixed"}).
#' @param seed Random seed.
#' @param ... extra parameters for calling function \code{\link{rwe_stan}}.
#'
#' @return A class \code{PSRWE_RST} list with the following objects
#'
#' \describe{
#'     \item{Observed}{Observed mean and SD of the outcome by group, arm
#'     and stratum}
#'
#'     \item{Control}{A list of estimated mean and SD of the outcome by stratum
#'     in the control arm}
#'
#'     \item{Treatment}{A list of estimated mean and SD of the outcome by
#'     stratum in the treatment arm for RCT}
#'
#'     \item{Effect}{A list of estimated mean and SD of the treatment effect by
#'     stratum for RCT}
#'
#'     \item{Borrow}{Borrowing information from \code{dta_psbor}}
#'
#'     \item{stan_rst}{Result from STAN sampling}
#' }
#'
#' @examples
#'
#' \donttest{
#' data(ex_dta)
#' dta_ps <- psrwe_est(ex_dta,
#'        v_covs = paste("V", 1:7, sep = ""),
#'        v_grp = "Group",
#'        cur_grp_level = "current",
#'        nstrata = 1)
#' ps_borrow <- psrwe_borrow(total_borrow = 30, dta_ps)
#' rst <- psrwe_powerp_watt(ps_borrow, v_outcome = "Y_Bin", seed = 123)}
#'
#' @export
#'
psrwe_powerp_watt <- function(dta_psbor, v_outcome = "Y",
                          outcome_type = c("continuous", "binary"),
                          prior_type = c("fixed", "random"),
                          mcmc_binary = c("rstan", "analytic"),
                          ..., seed = NULL) {

    ## check
    stopifnot(inherits(dta_psbor,
                       what = get_rwe_class("PSDIST")))

    type       <- match.arg(outcome_type)
    prior_type <- match.arg(prior_type)
    mcmc_binary <- match.arg(mcmc_binary)
    stopifnot(v_outcome %in% colnames(dta_psbor$data))

    ## save the seed from global if any then set random seed
    old_seed <- NULL
    if (!is.null(seed)) {
        if (exists(".Random.seed", envir = .GlobalEnv)) {
            old_seed <- get(".Random.seed", envir = .GlobalEnv)
        }
        set.seed(seed)
    }

    ## observed
    rst_obs <- get_observed(dta_psbor$data, v_outcome)

    ## prepare stan data
    lst_dta <- get_stan_data_watt(dta_psbor, v_outcome, prior_type)

    ## sampling
    stan_mdl <- if_else("continuous" == type,
                        "powerps",
                        "powerpsbinary")

    ## for summary
    is_rct     <- dta_psbor$is_rct
    trt_post   <- NULL
    trt_thetas <- NULL
    rst_trt    <- NULL
    rst_effect <- NULL

    if (!(type[1] == "binary" &&
          prior_type[1] == "fixed" &&
          mcmc_binary[1] == "analytic")) {
        ## regular MCMC via rstan
        ctl_post   <- rwe_stan(lst_data = lst_dta$ctl, stan_mdl = stan_mdl, ...)
        ctl_thetas <- extract(ctl_post, "thetas")$thetas
        n_ctl      <- dta_psbor$Borrow$N_Current

        if (is_rct) {
            trt_post <- rwe_stan(lst_data = lst_dta$trt,
                                 stan_mdl = stan_mdl, ...)
            trt_thetas <- extract(trt_post, "thetas")$thetas

            rst_trt    <- get_post_theta(trt_thetas, dta_psbor$Borrow$N_Cur_TRT)
            rst_effect <- get_post_theta(trt_thetas - ctl_thetas,
                                         dta_psbor$Borrow$N_Current)
            n_ctl      <- dta_psbor$Borrow$N_Cur_CTL
        }

        rst_ctl <- get_post_theta(ctl_thetas, n_ctl)
    } else {
        ## special case via the analytic solution for binary only
        ctl_post   <- rwe_binana(lst_data = lst_dta$ctl)
        ctl_thetas <- ctl_post$thetas
        n_ctl      <- dta_psbor$Borrow$N_Current

        if (is_rct) {
            trt_post <- rwe_binana(lst_data = lst_dta$trt)
            trt_thetas <- trt_post$thetas

            rst_trt    <- get_post_theta_binana(trt_thetas,
                                                dta_psbor$Borrow$N_Cur_TRT)
            rst_effect <- get_post_theta_binana(trt_thetas - ctl_thetas,
                                                dta_psbor$Borrow$N_Current)
            n_ctl      <- dta_psbor$Borrow$N_Cur_CTL
        }

        rst_ctl <- get_post_theta_binana(ctl_thetas, n_ctl)
    }

    ## reset the original seed back to the global or
    ## remove the one set within this session earlier.
    if (!is.null(seed)) {
        if (!is.null(old_seed)) {
            invisible(assign(".Random.seed", old_seed, envir = .GlobalEnv))
        } else {
            invisible(rm(list = c(".Random.seed"), envir = .GlobalEnv))
        }
    }

    ## return
    rst <-  list(stan_rst = list(ctl_post = ctl_post,
                                 trt_post = trt_post),
                 Observed  = rst_obs,
                 Control   = rst_ctl,
                 Treatment = rst_trt,
                 Effect    = rst_effect,
                 Borrow    = dta_psbor$Borrow,
                 Total_borrow  = dta_psbor$Total_borrow,
                 Method        = "ps_pp",
                 Method_weight = "WATT",
                 Outcome_type  = type,
                 Prior_type    = prior_type,
                 MCMC_binary   = mcmc_binary,
                 is_rct        = is_rct)

    class(rst) <- get_rwe_class("ANARST")
    rst
}


#' Get data for STAN watt
#'
#'
#' @noRd
#'
get_stan_data_watt <- function(dta_psbor, v_outcome, prior_type) {
    f_curd <- function(i, d1, d0 = NULL, d0_watt_di = NULL) {
        cur_d <- c(N1    = length(d1),
                   YBAR1 = mean(d1),
                   YSUM1 = sum(d1))

        if (is.null(d0)) {
            cur_d <- c(cur_d,
                       N0    = 0,
                       YBAR0 = 0,
                       SD0   = 0)
        } else {
            if (is.null(d0_watt_di)) {
                d0_watt_di <- rep(1 / length(d0) , length(d0))
            }

            cur_d <- c(cur_d,
                       N0    = length(d0),
                       YBAR0 = sum(d0 * d0_watt_di),  # Need to check continuous
                       SD0   = sd(d0 * d0_watt_di))   # Need to check continuous
        }

        list(stan_d = cur_d,
             y1     = d1,
             inx1   = rep(i, length(d1)))
    }

    is_rct  <- dta_psbor$is_rct
    data    <- dta_psbor$data
    data    <- data[!is.na(data[["_strata_"]]), ]

    strata  <- levels(data[["_strata_"]])
    nstrata <- length(strata)

    ctl_stan_d  <- NULL
    ctl_y1      <- NULL
    ctl_inx1    <- NULL

    trt_stan_d  <- NULL
    trt_y1      <- NULL
    trt_inx1    <- NULL

    for (i in seq_len(nstrata)) {
        cur_01  <- get_cur_d(data, strata[i], v_outcome)
        cur_d1  <- cur_01$cur_d1
        cur_d0  <- cur_01$cur_d0
        cur_d1t <- cur_01$cur_d1t

        cur_01_e  <- get_cur_d(data, strata[i], "_ps_")
        cur_d0_e  <- cur_01_e$cur_d0
        cur_d0_watt  <- cur_d0_e / (1 - cur_d0_e)
        cur_d0_watt_di  <- cur_d0_watt / sum(cur_d0_watt)

        ctl_cur    <- f_curd(i, cur_d1, cur_d0, cur_d0_watt_di)
        ctl_stan_d <- rbind(ctl_stan_d, ctl_cur$stan_d)
        ctl_y1     <- c(ctl_y1,   ctl_cur$y1)
        ctl_inx1   <- c(ctl_inx1, ctl_cur$inx1)

        if (is_rct) {
            trt_cur    <- f_curd(i, cur_d1t)
            trt_stan_d <- rbind(trt_stan_d, trt_cur$stan_d)
            trt_y1     <- c(trt_y1,   trt_cur$y1)
            trt_inx1   <- c(trt_inx1, trt_cur$inx1)
        }
    }

    ctl_lst_data  <- list(S     = nstrata,
                          A     = dta_psbor$Total_borrow,
                          RS    = as.array(dta_psbor$Borrow$Proportion),
                          FIXVS = as.numeric(prior_type == "fixed"),
                          N0    = as.array(ctl_stan_d[, "N0"]),
                          N1    = as.array(ctl_stan_d[, "N1"]),
                          YBAR0 = as.array(ctl_stan_d[, "YBAR0"]),
                          SD0   = as.array(ctl_stan_d[, "SD0"]),
                          TN1   = length(ctl_y1),
                          Y1    = ctl_y1,
                          INX1  = ctl_inx1,
                          YBAR1 = as.array(ctl_stan_d[, "YBAR1"]),
                          YSUM1 = as.array(ctl_stan_d[, "YSUM1"]))

    trt_lst_data <- NULL
    if (is_rct) {
        trt_lst_data  <- list(S     = nstrata,
                              A     = 0,
                              RS    = as.array(dta_psbor$Borrow$Proportion),
                              FIXVS = as.numeric("fixed" == "fixed"),
                              N0    = as.array(trt_stan_d[, "N0"]),
                              N1    = as.array(trt_stan_d[, "N1"]),
                              YBAR0 = as.array(trt_stan_d[, "YBAR0"]),
                              SD0   = as.array(trt_stan_d[, "SD0"]),
                              TN1   = length(trt_y1),
                              Y1    = trt_y1,
                              INX1  = trt_inx1,
                              YBAR1 = as.array(trt_stan_d[, "YBAR1"]),
                              YSUM1 = as.array(trt_stan_d[, "YSUM1"]))
    }


    list(ctl = ctl_lst_data,
         trt = trt_lst_data)
}


#' RWE binary analytical posterior
#'
#'
#' @noRd
#'
rwe_binana <- function(lst_data, beta_a_init = 1, beta_b_init = 1) {
    alpha0 <- lst_data$A * lst_data$RS / lst_data$N0
    alpha0[alpha0 > 1] <- 1

    n0 <- lst_data$N0
    n1 <- lst_data$N1
    p0 <- lst_data$YBAR0  # watt
    p1 <- lst_data$YBAR1

    ### posterior
    beta_a0   <- alpha0 * n0 * p0 + beta_a_init
    beta_b0   <- alpha0 * n0 * (1 - p0) + beta_b_init
    beta_a    <- n1 * p1 + beta_a0
    beta_b    <- n1 * (1 - p1) + beta_b0
    post_mean <- beta_a / (beta_a + beta_b)
    post_var  <- beta_a * beta_b / ((beta_a + beta_b)^2 *
                                    (beta_a + beta_b + 1))
    post_dsn  <- list(beta_a0 = beta_a0,
                      beta_b0 = beta_b0,
                      beta_a  = beta_a,
                      beta_b  = beta_b,
                      mean    = post_mean,
                      var     = post_var)

    ### return
    rst <- list(thetas = post_dsn)
    return(rst)
}


#' Get results for control, treatment and effect for binary analytical posterior
#'
#'
#' @noRd
#'
get_post_theta_binana <- function(thetas, weights, n_resample = 4000) {
    ns      <- length(weights)
    ws      <- weights / sum(weights)
    samples <- matrix(rbeta(ns * n_resample, thetas$beta_a, thetas$beta_b),
                      nrow = ns, ncol = n_resample)
    overall <- apply(samples, 2, function(x) sum(x * ws))

    means <- thetas$mean
    sds   <- sqrt(thetas$var)

    mean_overall <- sum(thetas$mean * ws)
    sd_overall   <- sqrt(sum(thetas$var * ws^2))

    list(Stratum_Samples  = samples,
         Overall_Samples  = overall,
         Stratum_Estimate = cbind(Mean   = means,
                                  StdErr = sds),
         Overall_Estimate = cbind(Mean   = mean_overall,
                                  StdErr = sd_overall))
}


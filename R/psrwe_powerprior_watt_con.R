#' Get posterior samples based on PS-power prior approach (WATT_CON)
#'
#' Draw posterior samples of the parameters of interest for the PS-power prior
#' approach with weights of ATT (WATT_CON) for continuous outcomes
#'
#'
#' @param dta_psbor A class \code{PSRWE_BOR} object generated by
#'     \code{\link{psrwe_borrow}}.
#' @param v_outcome Column name corresponding to the outcome.
#' @param outcome_type Type of outcomes: \code{continuous}.
#' @param seed Random seed.
#' @param ... extra parameters for calling function \code{\link{rwe_stan}}.
#'
#' @return A class \code{PSRWE_RST} list with the following objects
#'
#' \describe{
#'     \item{Observed}{Observed mean and SD of the outcome by group, arm
#'     and stratum}
#'
#'     \item{Control}{A list of estimated mean and SD of the outcome by stratum
#'     in the control arm}
#'
#'     \item{Treatment}{A list of estimated mean and SD of the outcome by
#'     stratum in the treatment arm for RCT}
#'
#'     \item{Effect}{A list of estimated mean and SD of the treatment effect by
#'     stratum for RCT}
#'
#'     \item{Borrow}{Borrowing information from \code{dta_psbor}}
#'
#'     \item{stan_rst}{Result from STAN sampling}
#' }
#'
#' @examples
#'
#' \donttest{
#' data(ex_dta)
#' dta_ps <- psrwe_est(ex_dta,
#'        v_covs = paste("V", 1:7, sep = ""),
#'        v_grp = "Group",
#'        cur_grp_level = "current",
#'        nstrata = 1)
#' ps_borrow <- psrwe_borrow(total_borrow = 30, dta_ps)
#' rst <- psrwe_powerp_watt_con(ps_borrow, v_outcome = "Y_Con", seed = 123)}
#'
#' @export
#'
psrwe_powerp_watt_con <- function(dta_psbor, v_outcome = "Y",
                          outcome_type = c("continuous"),
                          ..., seed = NULL) {

    ## check
    stopifnot(inherits(dta_psbor,
                       what = get_rwe_class("PSDIST")))

    type       <- match.arg(outcome_type)
    stopifnot(v_outcome %in% colnames(dta_psbor$data))
    stopifnot(dta_psbor$nstrata == 1)

    ## save the seed from global if any then set random seed
    old_seed <- NULL
    if (!is.null(seed)) {
        if (exists(".Random.seed", envir = .GlobalEnv)) {
            old_seed <- get(".Random.seed", envir = .GlobalEnv)
        }
        set.seed(seed)
    }

    ## observed
    rst_obs <- get_observed(dta_psbor$data, v_outcome)

    ## prepare stan data
    lst_dta <- get_stan_data_watt_con(dta_psbor, v_outcome)

    ## sampling
    stan_mdl <- "powerps_watt_con"

    ## run stan or get from analytical solution
    is_rct     <- dta_psbor$is_rct
    trt_post   <- NULL
    trt_thetas <- NULL

    ctl_post   <- rwe_stan(lst_data = lst_dta$ctl, stan_mdl = stan_mdl, ...)
    ctl_thetas <- extract(ctl_post, "thetas")$thetas

    if (is_rct) {
        trt_post <- rwe_stan(lst_data = lst_dta$trt,
                             stan_mdl = stan_mdl, ...)
        trt_thetas <- extract(trt_post, "thetas")$thetas
    }

    ## summary
    rst_trt    <- NULL
    rst_effect <- NULL
    if (is_rct) {
        rst_trt    <- get_post_theta(trt_thetas, dta_psbor$Borrow$N_Cur_TRT)
        rst_effect <- get_post_theta(trt_thetas - ctl_thetas,
                                     dta_psbor$Borrow$N_Current)
        n_ctl      <- dta_psbor$Borrow$N_Cur_CTL
    } else {
        n_ctl      <- dta_psbor$Borrow$N_Current
    }
    rst_ctl <- get_post_theta(ctl_thetas, n_ctl)

    ## reset the original seed back to the global or
    ## remove the one set within this session earlier.
    if (!is.null(seed)) {
        if (!is.null(old_seed)) {
            invisible(assign(".Random.seed", old_seed, envir = .GlobalEnv))
        } else {
            invisible(rm(list = c(".Random.seed"), envir = .GlobalEnv))
        }
    }

    ## return
    rst <-  list(stan_rst = list(ctl_post = ctl_post,
                                 trt_post = trt_post),
                 Observed  = rst_obs,
                 Control   = rst_ctl,
                 Treatment = rst_trt,
                 Effect    = rst_effect,
                 Borrow    = dta_psbor$Borrow,
                 Total_borrow  = dta_psbor$Total_borrow,
                 Method        = "ps_pp",
                 Method_weight = "WATT",
                 Outcome_type  = type,
                 Prior_type    = "fixed",
                 MCMC_method   = mcmc_method,
                 is_rct        = is_rct)

    class(rst) <- get_rwe_class("ANARST")
    rst
}


#' Get data for STAN watt for continuous outcomes
#'
#'
#' @noRd
#'
get_stan_data_watt_con <- function(dta_psbor, v_outcome) {
    is_rct  <- dta_psbor$is_rct
    data    <- dta_psbor$data
    data    <- data[!is.na(data[["_strata_"]]), ]
    A       <- dta_psbor$Total_borrow

    ctl_y1      <- NULL
    trt_y1      <- NULL

browser()
    cur_01  <- get_cur_d(data, 1, v_outcome)
    cur_d1  <- cur_01$cur_d1
    cur_d0  <- cur_01$cur_d0
    cur_d1t <- cur_01$cur_d1t

    cur_01_e <- get_cur_d(data, 1, "_ps_")
    cur_d0_e <- cur_01_e$cur_d0
    cur_d0_watt <- cur_d0_e / (1 - cur_d0_e)

    ctl_y1 <- cur_d1
    ctl_y0 <- cur_d0
    ctl_a_watt_di <- A * cur_d0_watt / sum(cur_d0_watt)

    if (is_rct) {
        trt_y1 <- cur_d1t
    }

    ctl_lst_data  <- list(A         = A,
                          N0        = length(ctl_y0),
                          Y0        = ctl_y0,
                          A_WATT_DI = ctl_a_watt_di,
                          N1        = length(ctl_y1),
                          Y1        = ctl_y1)

    trt_lst_data <- NULL
    if (is_rct) {
        trt_lst_data  <- list(A     = 0,
                              N0    = 0,
                              Y0    = 0,
                              N1    = length(trt_y1),
                              Y1    = trt_y1)
    }

    list(ctl = ctl_lst_data,
         trt = trt_lst_data)
}

